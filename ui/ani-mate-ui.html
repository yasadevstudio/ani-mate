<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ANI-MATE // Free Anime For All</title>
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@400;700;900&family=Jura:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="/hls.min.js"></script>
    <style>
        /* === RESET & BASE === */
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #000000;
            --accent-gold: #ffdd00;
            --accent-cyan: #00ffff;
            --accent-magenta: #ff00ff;
            --glass-bg: rgba(0, 255, 255, 0.03);
            --glass-border: rgba(0, 255, 255, 0.15);
            --glass-hover: rgba(0, 255, 255, 0.08);
            --text-primary: #e0e0e0;
            --text-dim: #888;
            --danger: #ff3333;
            --success: #00ff88;
        }

        body {
            background: var(--bg);
            color: var(--text-primary);
            font-family: 'Jura', sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* === NEURAL PARTICLE CANVAS === */
        #neural-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        /* === CRT SCANLINES === */
        .crt-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 9999;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.08) 2px,
                rgba(0, 0, 0, 0.08) 4px
            );
        }

        /* === GLASS MORPHISM === */
        .glass {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 4px;
        }

        .glass:hover {
            background: var(--glass-hover);
            border-color: rgba(0, 255, 255, 0.3);
        }

        /* === LAYOUT === */
        .app-container {
            position: relative;
            z-index: 1;
            display: grid;
            grid-template-rows: 48px 1fr;
            grid-template-columns: 320px 1fr 280px;
            grid-template-areas:
                "header header header"
                "left center right";
            height: 100vh;
            gap: 4px;
            padding: 4px;
        }

        /* === HEADER BAR === */
        .header {
            grid-area: header;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            border-bottom: 1px solid var(--glass-border);
        }

        .header-title {
            font-family: 'Audiowide', cursive;
            font-size: 20px;
            color: var(--accent-gold);
            text-shadow: 0 0 20px rgba(255, 221, 0, 0.5);
            letter-spacing: 3px;
        }

        .header-title span {
            color: var(--accent-cyan);
        }

        .header-presented {
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            color: var(--text-dim);
            letter-spacing: 2px;
            text-transform: uppercase;
            text-decoration: none;
            margin-left: 12px;
            vertical-align: middle;
            transition: color 0.3s, text-shadow 0.3s;
        }

        .header-presented:hover {
            color: var(--accent-gold);
            text-shadow: 0 0 10px rgba(255, 221, 0, 0.4);
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 12px;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .status-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: var(--danger);
            box-shadow: 0 0 8px var(--danger);
            animation: pulse 2s infinite;
        }

        .status-dot.online {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* === LEFT PANEL - SEARCH === */
        .left-panel {
            grid-area: left;
            display: flex;
            flex-direction: column;
            gap: 4px;
            overflow: hidden;
        }

        .search-box {
            padding: 12px;
        }

        .search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .search-input {
            width: 100%;
            padding: 10px 40px 10px 12px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--glass-border);
            border-radius: 3px;
            color: var(--accent-cyan);
            font-family: 'Jura', sans-serif;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        .search-input:focus {
            border-color: var(--accent-gold);
            box-shadow: 0 0 15px rgba(255, 221, 0, 0.15);
        }

        .search-input::placeholder {
            color: var(--text-dim);
            font-style: italic;
        }

        .search-btn {
            position: absolute;
            right: 4px;
            background: none;
            border: none;
            color: var(--accent-gold);
            cursor: pointer;
            padding: 6px 8px;
            font-size: 16px;
            transition: text-shadow 0.3s;
        }

        .search-btn:hover {
            text-shadow: 0 0 10px var(--accent-gold);
        }

        .mode-toggle {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }

        .mode-btn {
            flex: 1;
            padding: 6px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--glass-border);
            border-radius: 2px;
            color: var(--text-dim);
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-btn.active {
            color: var(--accent-gold);
            border-color: var(--accent-gold);
            background: rgba(255, 221, 0, 0.08);
            box-shadow: 0 0 10px rgba(255, 221, 0, 0.1);
        }

        /* === RESULTS LIST === */
        .results-container {
            flex: 1;
            overflow-y: auto;
            padding: 0 8px 8px;
        }

        .results-container::-webkit-scrollbar { width: 4px; }
        .results-container::-webkit-scrollbar-track { background: transparent; }
        .results-container::-webkit-scrollbar-thumb { background: var(--glass-border); border-radius: 2px; }

        .result-card {
            padding: 10px 12px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 2px solid transparent;
        }

        .result-card:hover {
            border-left-color: var(--accent-cyan);
        }

        .result-card.selected {
            border-left-color: var(--accent-gold);
            background: rgba(255, 221, 0, 0.06);
        }

        .result-title {
            font-family: 'Jura', sans-serif;
            font-size: 13px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
            line-height: 1.3;
        }

        .result-meta {
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            color: var(--accent-cyan);
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .result-type {
            display: inline-block;
            padding: 1px 6px;
            border-radius: 2px;
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            letter-spacing: 1px;
            margin-right: 6px;
        }

        .result-type.series {
            color: var(--accent-gold);
            border: 1px solid rgba(255, 221, 0, 0.3);
        }

        .result-type.short {
            color: var(--accent-cyan);
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .result-type.movie {
            color: var(--accent-magenta);
            border: 1px solid rgba(255, 0, 255, 0.3);
        }

        /* === TAB BAR === */
        .tab-bar {
            display: flex;
            gap: 2px;
            padding: 6px 8px;
            border-bottom: 1px solid rgba(255, 221, 0, 0.1);
        }

        .tab-btn {
            flex: 1;
            padding: 6px 2px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--glass-border);
            border-radius: 2px;
            color: var(--text-dim);
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
        }

        .tab-btn.active {
            color: var(--accent-gold);
            border-color: var(--accent-gold);
            background: rgba(255, 221, 0, 0.08);
        }

        /* === STAR BUTTON === */
        .fav-star {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            padding: 2px 4px;
            transition: all 0.2s;
            color: var(--text-dim);
        }

        .fav-star:hover { color: var(--accent-gold); }
        .fav-star.active { color: var(--accent-gold); text-shadow: 0 0 8px rgba(255, 221, 0, 0.5); }

        .result-card-row {
            display: flex;
            align-items: flex-start;
            gap: 6px;
        }

        .result-card-row .result-info { flex: 1; min-width: 0; }

        .section-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            color: var(--accent-gold);
            letter-spacing: 3px;
            text-transform: uppercase;
            padding: 12px 12px 6px;
            border-bottom: 1px solid rgba(255, 221, 0, 0.1);
            margin-bottom: 4px;
        }

        .no-results {
            text-align: center;
            padding: 40px 16px;
            color: var(--text-dim);
            font-size: 12px;
            font-style: italic;
        }

        .loading-indicator {
            text-align: center;
            padding: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: var(--accent-cyan);
            letter-spacing: 3px;
            animation: pulse 1s infinite;
        }

        /* === CENTER PANEL - PLAYER === */
        .center-panel {
            grid-area: center;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .player-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: center;
            min-height: 0;
            overflow: hidden;
            position: relative;
        }

        .player-splash {
            text-align: center;
            padding: 40px;
        }

        .player-splash-link {
            display: inline-block;
            margin-bottom: 6px;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            color: var(--accent-gold);
            letter-spacing: 5px;
            text-transform: uppercase;
            text-decoration: none;
            transition: text-shadow 0.3s, color 0.3s;
            opacity: 0;
            animation: splashGlitchIn 0.6s ease-out 0.2s forwards;
        }

        .player-splash-link:hover {
            text-shadow: 0 0 15px rgba(255, 221, 0, 0.6), 0 0 30px rgba(255, 221, 0, 0.3);
            color: #fff;
        }

        .player-splash-presents {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: var(--accent-cyan);
            letter-spacing: 6px;
            text-transform: uppercase;
            margin-bottom: 8px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
            opacity: 0;
            animation: splashCyanPulse 0.5s ease-out 0.8s forwards;
        }

        .player-splash-title {
            font-family: 'Audiowide', cursive;
            font-size: 48px;
            color: var(--accent-gold);
            text-shadow: 0 0 40px rgba(255, 221, 0, 0.3), 0 0 80px rgba(255, 221, 0, 0.1);
            margin-bottom: 8px;
            opacity: 0;
            animation: splashGlitchReveal 1.2s ease-out 1.3s forwards, glitch 8s 2.5s infinite;
        }

        .player-splash-sub {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: var(--accent-cyan);
            letter-spacing: 5px;
            text-transform: uppercase;
            opacity: 0;
            animation: splashFadeUp 0.5s ease-out 1.9s forwards;
        }

        .player-splash-ver {
            font-family: 'Jura', sans-serif;
            font-size: 10px;
            color: var(--text-dim);
            margin-top: 16px;
            letter-spacing: 2px;
            opacity: 0;
            animation: splashFadeUp 0.5s ease-out 2.2s forwards;
        }

        @keyframes splashGlitchIn {
            0% { opacity: 0; transform: translateX(-20px) skewX(-10deg); filter: blur(4px); }
            30% { opacity: 0.7; transform: translateX(5px) skewX(3deg); filter: blur(1px); }
            50% { opacity: 0.4; transform: translateX(-3px) skewX(-2deg); filter: blur(2px); }
            70% { opacity: 0.9; transform: translateX(2px) skewX(1deg); filter: blur(0); }
            100% { opacity: 1; transform: translateX(0) skewX(0); filter: blur(0); }
        }

        @keyframes splashCyanPulse {
            0% { opacity: 0; letter-spacing: 12px; text-shadow: 0 0 30px rgba(0, 255, 255, 0.8); }
            50% { opacity: 1; text-shadow: 0 0 20px rgba(0, 255, 255, 0.6); }
            100% { opacity: 1; letter-spacing: 6px; text-shadow: 0 0 10px rgba(0, 255, 255, 0.4); }
        }

        @keyframes splashSlam {
            0% { opacity: 0; transform: scale(0.3); text-shadow: 0 0 0 transparent; }
            60% { opacity: 1; transform: scale(1.1); text-shadow: 0 0 80px rgba(255, 221, 0, 0.6), 0 0 120px rgba(255, 221, 0, 0.3); }
            80% { transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1); text-shadow: 0 0 40px rgba(255, 221, 0, 0.3), 0 0 80px rgba(255, 221, 0, 0.1); }
        }

        @keyframes splashGlitchReveal {
            0% { opacity: 0; transform: skewX(-15deg); filter: blur(8px); clip-path: inset(0 100% 0 0); }
            10% { opacity: 0.3; transform: skewX(8deg); filter: blur(4px); clip-path: inset(0 70% 0 0); }
            20% { opacity: 0.1; transform: skewX(-5deg) translateX(-8px); filter: blur(6px); clip-path: inset(0 50% 0 0); }
            35% { opacity: 0.6; transform: skewX(4deg) translateX(4px); filter: blur(2px); clip-path: inset(0 30% 0 0); }
            45% { opacity: 0.3; transform: skewX(-3deg) translateX(-3px); filter: blur(3px); clip-path: inset(0 20% 0 0); }
            60% { opacity: 0.8; transform: skewX(2deg); filter: blur(1px); clip-path: inset(0 5% 0 0); }
            75% { opacity: 0.5; transform: skewX(-1deg); filter: blur(2px); clip-path: inset(0 0 0 0); }
            85% { opacity: 0.9; transform: skewX(1deg); filter: blur(0); }
            95% { opacity: 1; transform: skewX(-0.5deg); }
            100% { opacity: 1; transform: skewX(0); filter: blur(0); clip-path: inset(0 0 0 0); text-shadow: 0 0 40px rgba(255, 221, 0, 0.3), 0 0 80px rgba(255, 221, 0, 0.1); }
        }

        @keyframes splashFadeUp {
            0% { opacity: 0; transform: translateY(10px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        /* Episode Grid */
        .episode-grid-container {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            display: none;
            min-height: 0;
        }

        .episode-grid-container::-webkit-scrollbar { width: 4px; }
        .episode-grid-container::-webkit-scrollbar-track { background: transparent; }
        .episode-grid-container::-webkit-scrollbar-thumb { background: var(--glass-border); border-radius: 2px; }

        .selected-anime-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-left: 3px solid var(--accent-gold);
        }

        .selected-anime-title {
            font-family: 'Jura', sans-serif;
            font-size: 16px;
            font-weight: 700;
            color: var(--accent-gold);
        }

        .selected-anime-count {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: var(--accent-cyan);
            letter-spacing: 1px;
        }

        .anime-description {
            padding: 6px 12px 10px;
            font-size: 12px;
            line-height: 1.5;
            color: var(--text-dim);
            max-height: 120px;
            overflow-y: auto;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            margin-bottom: 8px;
        }

        .anime-description::-webkit-scrollbar { width: 4px; }
        .anime-description::-webkit-scrollbar-track { background: transparent; }
        .anime-description::-webkit-scrollbar-thumb { background: var(--glass-border); border-radius: 2px; }

        .anime-description .anime-genres {
            margin-top: 4px;
            font-size: 10px;
            color: var(--accent-cyan);
            letter-spacing: 0.5px;
        }

        .anime-description .anime-score {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: var(--accent-gold);
        }

        .range-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
        }

        .range-btn {
            padding: 4px 10px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--glass-border);
            border-radius: 2px;
            color: var(--text-dim);
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .range-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .range-btn.active {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: rgba(255, 221, 0, 0.08);
        }

        .episode-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(54px, 1fr));
            gap: 4px;
        }

        .episode-btn {
            padding: 8px 4px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--glass-border);
            border-radius: 2px;
            color: var(--text-primary);
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .episode-btn:hover {
            border-color: var(--accent-cyan);
            background: rgba(0, 255, 255, 0.08);
            color: var(--accent-cyan);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.1);
        }

        .episode-btn.watched {
            border-color: rgba(0, 255, 136, 0.4);
            color: var(--success);
            opacity: 0.6;
            background: rgba(0, 255, 136, 0.04);
        }

        .episode-btn.playing {
            border-color: var(--success);
            background: rgba(0, 255, 136, 0.1);
            color: var(--success);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.2);
        }

        /* === PLAYER CONTROLS BAR === */
        .controls-bar {
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .control-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            color: var(--text-dim);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .control-select {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--glass-border);
            border-radius: 2px;
            color: var(--accent-cyan);
            font-family: 'Jura', sans-serif;
            font-size: 12px;
            padding: 4px 8px;
            outline: none;
            cursor: pointer;
        }

        .control-select:focus {
            border-color: var(--accent-gold);
        }

        .control-select option {
            background: #111;
            color: var(--text-primary);
        }

        .play-btn {
            padding: 8px 20px;
            background: linear-gradient(135deg, rgba(255, 221, 0, 0.15), rgba(255, 221, 0, 0.05));
            border: 1px solid var(--accent-gold);
            border-radius: 3px;
            color: var(--accent-gold);
            font-family: 'Audiowide', cursive;
            font-size: 12px;
            letter-spacing: 3px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
            margin-left: auto;
        }

        .play-btn:hover {
            background: linear-gradient(135deg, rgba(255, 221, 0, 0.3), rgba(255, 221, 0, 0.1));
            box-shadow: 0 0 20px rgba(255, 221, 0, 0.2);
            text-shadow: 0 0 10px var(--accent-gold);
        }

        .play-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .now-playing {
            flex: 1;
            min-width: 200px;
        }

        .now-playing-title {
            font-family: 'Jura', sans-serif;
            font-size: 13px;
            color: var(--accent-gold);
            font-weight: 700;
        }

        .now-playing-detail {
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            color: var(--accent-cyan);
            letter-spacing: 1px;
            margin-top: 2px;
        }

        /* === RIGHT PANEL - HISTORY === */
        .right-panel {
            grid-area: right;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .history-list {
            flex: 1;
            overflow-y: auto;
            padding: 0 8px 8px;
        }

        .history-list::-webkit-scrollbar { width: 4px; }
        .history-list::-webkit-scrollbar-track { background: transparent; }
        .history-list::-webkit-scrollbar-thumb { background: var(--glass-border); border-radius: 2px; }

        .history-item {
            padding: 8px 10px;
            margin-bottom: 3px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 2px solid transparent;
        }

        .history-item:hover {
            border-left-color: var(--accent-magenta);
        }

        .history-title {
            font-family: 'Jura', sans-serif;
            font-size: 12px;
            color: var(--text-primary);
            font-weight: 500;
            line-height: 1.3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .history-meta {
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            color: var(--text-dim);
            letter-spacing: 1px;
            margin-top: 2px;
        }

        .history-meta span {
            color: var(--accent-magenta);
        }

        .clear-history-btn {
            margin: 8px;
            padding: 6px;
            background: none;
            border: 1px solid rgba(255, 51, 51, 0.3);
            border-radius: 2px;
            color: var(--danger);
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            letter-spacing: 2px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
        }

        .clear-history-btn:hover {
            background: rgba(255, 51, 51, 0.1);
            border-color: var(--danger);
        }

        /* === CONTEXT MENU === */
        .ctx-menu {
            position: fixed;
            z-index: 9999;
            background: rgba(10, 10, 20, 0.95);
            border: 1px solid var(--accent-gold);
            border-radius: 4px;
            padding: 4px 0;
            min-width: 160px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6);
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            letter-spacing: 1px;
            display: none;
        }
        .ctx-menu-item {
            padding: 8px 14px;
            color: var(--danger);
            cursor: pointer;
            transition: background 0.2s;
        }
        .ctx-menu-item:hover {
            background: rgba(255, 51, 51, 0.15);
        }

        /* === STATUS BAR (notification toast) === */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9998;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .toast {
            padding: 10px 16px;
            border-radius: 3px;
            font-family: 'Jura', sans-serif;
            font-size: 12px;
            animation: toastIn 0.3s ease, toastOut 0.3s ease 3.7s forwards;
            max-width: 350px;
        }

        .toast.info {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .toast.success {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--success);
            color: var(--success);
        }

        .toast.error {
            background: rgba(255, 51, 51, 0.1);
            border: 1px solid var(--danger);
            color: var(--danger);
        }

        @keyframes toastIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes toastOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* === GLITCH TEXT EFFECT === */
        @keyframes glitch {
            0%, 90%, 100% { transform: none; }
            91% { transform: skewX(-2deg); }
            93% { transform: skewX(2deg); }
            95% { transform: skewX(-1deg); }
        }

        .glitch { animation: glitch 8s infinite; }

        /* === DATE NAVIGATION === */
        .date-nav {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255, 221, 0, 0.15);
            margin-bottom: 4px;
        }
        .date-nav-btn {
            background: none;
            border: 1px solid var(--glass-border);
            border-radius: 2px;
            color: var(--accent-cyan);
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            letter-spacing: 1px;
            padding: 4px 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .date-nav-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }
        .date-nav-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: var(--accent-gold);
            letter-spacing: 2px;
        }

        /* === RELEASE CARDS === */
        .release-cover-wrap {
            width: 36px;
            height: 50px;
            flex-shrink: 0;
            border-radius: 2px;
            overflow: hidden;
            border: 1px solid var(--glass-border);
            margin-right: 8px;
        }
        .release-cover {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .release-time {
            color: var(--accent-cyan);
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            letter-spacing: 1px;
        }

        /* === AUTO-PLAY TOGGLE === */
        .autoplay-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .autoplay-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 8px;
            color: var(--text-dim);
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .toggle-switch {
            position: relative;
            width: 32px;
            height: 16px;
            cursor: pointer;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            transition: all 0.3s;
        }

        .toggle-slider::before {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            left: 2px;
            top: 2px;
            background: var(--text-dim);
            border-radius: 50%;
            transition: all 0.3s;
        }

        .toggle-switch input:checked + .toggle-slider {
            background: rgba(0, 255, 255, 0.15);
            border-color: var(--accent-cyan);
        }

        .toggle-switch input:checked + .toggle-slider::before {
            transform: translateX(16px);
            background: var(--accent-cyan);
            box-shadow: 0 0 6px var(--accent-cyan);
        }

        /* === VIDEO PLAYER === */
        .video-player-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #000;
            display: none;
            z-index: 10;
        }

        .video-player-container video {
            width: 100%;
            height: 100%;
            outline: none;
        }

        .player-back-btn {
            position: absolute;
            top: 12px;
            left: 12px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--accent-gold);
            border-radius: 3px;
            color: var(--accent-gold);
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            letter-spacing: 2px;
            padding: 6px 14px;
            cursor: pointer;
            transition: all 0.3s;
            opacity: 0.85;
        }

        :fullscreen .player-back-btn,
        :-webkit-full-screen .player-back-btn {
            opacity: 0;
            pointer-events: none;
        }

        .player-back-btn:hover {
            background: rgba(255, 221, 0, 0.15);
            box-shadow: 0 0 12px rgba(255, 221, 0, 0.3);
        }

        .player-loading-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.8);
            z-index: 15;
        }

        .player-loading-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: var(--accent-cyan);
            letter-spacing: 4px;
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <canvas id="neural-canvas"></canvas>
    <div class="crt-overlay"></div>

    <div class="app-container">
        <!-- HEADER -->
        <div class="header glass">
            <div class="header-title glitch">
                ANI<span>-</span>MATE
                <a href="https://yasa.work" target="_blank" class="header-presented" title="Visit YASA Development Studio website">presented by YASA Development Studio</a>
            </div>
            <div class="header-status">
                <div class="status-dot" id="status-dot" title="Server connection status"></div>
                <span id="status-text" title="Server connection status">OFFLINE</span>
            </div>
        </div>

        <!-- LEFT PANEL -->
        <div class="left-panel">
            <div class="tab-bar">
                <button class="tab-btn active" data-tab="search" id="tab-search" title="Search for anime">SEARCH</button>
                <button class="tab-btn" data-tab="continue" id="tab-continue" title="Resume watching where you left off">CONTINUE</button>
                <button class="tab-btn" data-tab="daily" id="tab-daily" title="Today's trending anime">DAILY</button>
                <button class="tab-btn" data-tab="releases" id="tab-releases" title="Airing schedule and new releases">RELEASES</button>
                <button class="tab-btn" data-tab="favs" id="tab-favs" title="Your saved favorite anime">FAVS</button>
            </div>
            <div class="search-box glass">
                <div class="search-input-wrapper">
                    <input type="text" class="search-input" id="search-input" placeholder="SEARCH ANIME DATABASE..." autocomplete="off" title="Type an anime name and press Enter to search">
                    <button class="search-btn" id="search-btn" title="Search anime database">&#9906;</button>
                </div>
                <div class="mode-toggle">
                    <button class="mode-btn active" data-mode="sub" id="mode-sub" title="Search for subtitled (Japanese audio) anime">SUB</button>
                    <button class="mode-btn" data-mode="dub" id="mode-dub" title="Search for dubbed (English audio) anime">DUB</button>
                </div>
            </div>
            <div class="results-container" id="results-container">
                <div class="no-results">Enter a search query to find anime</div>
            </div>
        </div>

        <!-- CENTER PANEL -->
        <div class="center-panel">
            <div class="controls-bar glass">
                <div class="now-playing" id="now-playing-info">
                    <div class="now-playing-title" id="np-title">No Selection</div>
                    <div class="now-playing-detail" id="np-detail">Select an anime to begin</div>
                </div>
                <div class="control-group">
                    <span class="control-label">Quality</span>
                    <select class="control-select" id="quality-select" title="Select video quality - changes apply during playback">
                        <option value="best">BEST</option>
                        <option value="1080">1080p</option>
                        <option value="720">720p</option>
                        <option value="480">480p</option>
                        <option value="360">360p</option>
                        <option value="worst">WORST</option>
                    </select>
                </div>
                <div class="control-group">
                    <span class="control-label">Audio</span>
                    <select class="control-select" id="audio-select" title="Select audio language">
                        <option value="sub">SUB</option>
                        <option value="dub">DUB</option>
                    </select>
                </div>
                <div class="autoplay-toggle" title="Auto-play next episode when current one ends">
                    <span class="autoplay-label">AUTO</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="autoplay-toggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <button class="play-btn" id="play-btn" disabled title="Play selected episode (Enter)">&#9654; PLAY</button>
                <button class="play-btn" id="dl-btn" disabled title="Download selected episode to ~/Videos/ANI-MATE/" style="font-size:10px;padding:8px 12px;letter-spacing:2px;border-color:var(--accent-cyan);color:var(--accent-cyan);background:linear-gradient(135deg, rgba(0,255,255,0.1), rgba(0,255,255,0.03))">&#8615; DL</button>
            </div>
            <div class="player-area glass">
                <div class="video-player-container" id="video-player-container">
                    <button class="player-back-btn" id="player-back-btn" title="Return to episode list (Escape)">&laquo; EPISODE LIST</button>
                    <div class="player-loading-overlay" id="player-loading" style="display:none">
                        <div class="player-loading-text">LOADING STREAM...</div>
                    </div>
                    <video id="video-player" controls></video>
                </div>
                <div class="player-splash" id="player-splash">
                    <a href="https://yasa.work" target="_blank" class="player-splash-link" title="Visit YASA Development Studio website">YASA Development Studio</a>
                    <div class="player-splash-presents">PRESENTS</div>
                    <div class="player-splash-title">ANI-MATE</div>
                    <div class="player-splash-sub">FREE ANIME FOR ALL</div>
                    <div class="player-splash-tagline" style="font-family:'Jura',sans-serif;font-size:12px;color:var(--text-dim);margin-top:8px;letter-spacing:1px">Stream 95% of all anime ever made</div>
                    <div class="player-splash-ver">v0.2.8 // YASA SYSTEMS ACTIVE</div>
                </div>
                <div class="episode-grid-container glass" id="episode-grid-container">
                    <div class="selected-anime-header">
                        <div style="display:flex;align-items:center;gap:6px;min-width:0;flex:1">
                            <div class="selected-anime-title" id="selected-anime-title" style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap">--</div>
                            <button class="fav-star" id="header-fav-star" title="Toggle favorite for this anime">&#9734;</button>
                        </div>
                        <div class="selected-anime-count" id="selected-anime-count">--</div>
                    </div>
                    <div class="anime-description" id="anime-description" style="display:none"></div>
                    <div class="range-selector" id="range-selector" style="display:none"></div>
                    <div class="episode-grid" id="episode-grid"></div>
                </div>
            </div>
        </div>

        <!-- RIGHT PANEL -->
        <div class="right-panel">
            <div class="section-label">WATCH HISTORY</div>
            <div class="history-list" id="history-list">
                <div class="no-results">No watch history yet</div>
            </div>
            <button class="clear-history-btn" id="clear-history-btn" title="Clear all watch history">CLEAR HISTORY</button>
        </div>
    </div>

    <div class="ctx-menu" id="ctx-menu">
        <div class="ctx-menu-item" id="ctx-remove">REMOVE</div>
    </div>
    <div class="toast-container" id="toast-container"></div>

    <script>
    // === ANI-MATE CLIENT ENGINE ===
    const API = window.location.origin;

    // State
    const state = {
        mode: 'sub',
        selectedAnime: null,
        selectedEpisode: null,
        episodes: [],
        results: [],
        history: [],
        serverOnline: false,
        availableLinks: [],
        hlsInstance: null,
        isPlaying: false,
        watchedMarked: false,
        currentPlaybackTime: 0,
        progressSaveInterval: null,
        pendingResumeTime: 0,
        autoPlay: false
    };

    // === NEURAL PARTICLE CANVAS ===
    const canvas = document.getElementById('neural-canvas');
    const ctx = canvas.getContext('2d');
    let particles = [];
    let connections = [];

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    class Particle {
        constructor() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.vx = (Math.random() - 0.5) * 0.3;
            this.vy = (Math.random() - 0.5) * 0.3;
            this.radius = Math.random() * 1.5 + 0.5;
            this.alpha = Math.random() * 0.4 + 0.1;
            this.color = Math.random() > 0.5 ? '0, 255, 255' : '255, 221, 0';
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
            if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${this.color}, ${this.alpha})`;
            ctx.fill();
        }
    }

    // Initialize particles
    for (let i = 0; i < 80; i++) {
        particles.push(new Particle());
    }

    function drawConnections() {
        for (let i = 0; i < particles.length; i++) {
            for (let j = i + 1; j < particles.length; j++) {
                const dx = particles[i].x - particles[j].x;
                const dy = particles[i].y - particles[j].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 150) {
                    const alpha = (1 - dist / 150) * 0.08;
                    ctx.beginPath();
                    ctx.moveTo(particles[i].x, particles[i].y);
                    ctx.lineTo(particles[j].x, particles[j].y);
                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
        }
    }

    function animateParticles() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach(p => { p.update(); p.draw(); });
        drawConnections();
        requestAnimationFrame(animateParticles);
    }
    animateParticles();

    // === TOAST NOTIFICATIONS ===
    function toast(message, type = 'info') {
        const container = document.getElementById('toast-container');
        const el = document.createElement('div');
        el.className = `toast ${type}`;
        el.textContent = message;
        container.appendChild(el);
        setTimeout(() => el.remove(), 4000);
    }

    // === API CALLS ===
    async function apiCall(endpoint, options = {}) {
        const resp = await fetch(`${API}${endpoint}`, options);
        if (!resp.ok) {
            const err = await resp.json().catch(() => ({ error: 'Unknown error' }));
            throw new Error(err.error || `HTTP ${resp.status}`);
        }
        return resp.json();
    }

    async function checkStatus() {
        try {
            const data = await apiCall('/status');
            state.serverOnline = true;
            document.getElementById('status-dot').classList.add('online');
            document.getElementById('status-text').textContent = 'ONLINE';
            return data;
        } catch {
            state.serverOnline = false;
            document.getElementById('status-dot').classList.remove('online');
            document.getElementById('status-text').textContent = 'OFFLINE';
            return null;
        }
    }

    async function searchAnime(query) {
        const container = document.getElementById('results-container');
        container.innerHTML = '<div class="loading-indicator">SCANNING DATABASE...</div>';

        try {
            const data = await apiCall(`/search?q=${encodeURIComponent(query)}&mode=${state.mode}`);
            state.results = data.results || [];
            renderResults();
        } catch (err) {
            container.innerHTML = `<div class="no-results">Error: ${err.message}</div>`;
            toast(err.message, 'error');
        }
    }

    async function loadEpisodes(animeId, title, epCount) {
        state.selectedAnime = { id: animeId, title, epCount };
        state.selectedEpisode = null;
        state.currentRange = 0;
        updatePlayButton();

        document.getElementById('np-title').textContent = title;
        document.getElementById('np-detail').textContent = `${epCount} episodes // ${state.mode.toUpperCase()}`;

        const gridContainer = document.getElementById('episode-grid-container');
        const splash = document.getElementById('player-splash');
        splash.style.display = 'none';
        gridContainer.style.display = 'block';

        document.getElementById('selected-anime-title').textContent = title;
        document.getElementById('selected-anime-count').textContent = `${epCount} EP`;
        updateHeaderStar();

        // Fetch and show anime description
        const descEl = document.getElementById('anime-description');
        descEl.style.display = 'none';
        descEl.innerHTML = '';
        apiCall(`/info?title=${encodeURIComponent(title)}`).then(info => {
            if (info.description) {
                const cleanDesc = info.description.replace(/<br\s*\/?>/gi, ' ').replace(/<[^>]*>/g, '');
                let html = cleanDesc;
                if (info.genres && info.genres.length > 0) {
                    html += `<div class="anime-genres">${info.genres.join(' // ')}</div>`;
                }
                if (info.score) {
                    html += `<span class="anime-score"> ${info.score}%</span>`;
                }
                descEl.innerHTML = html;
                descEl.style.display = 'block';
            }
        }).catch(() => {});

        const grid = document.getElementById('episode-grid');
        grid.innerHTML = '<div class="loading-indicator">LOADING EPISODES...</div>';

        try {
            const data = await apiCall(`/episodes?id=${encodeURIComponent(animeId)}&mode=${state.mode}`);
            state.episodes = data.episodes || [];
            renderEpisodeGrid();

            // Auto-select pending episode (from Continue Watching)
            if (state.pendingAutoEpisode) {
                const autoEp = state.pendingAutoEpisode;
                const hasResume = state.pendingResumeTime > 0;
                state.pendingAutoEpisode = null;
                if (state.episodes.includes(autoEp) || state.episodes.includes(String(autoEp))) {
                    state.selectedEpisode = String(autoEp);
                    updatePlayButton();
                    const resumeLabel = hasResume ? ` (resuming at ${formatTime(state.pendingResumeTime)})` : '';
                    document.getElementById('np-detail').textContent =
                        `EP ${autoEp} selected // ${state.mode.toUpperCase()}${resumeLabel}`;
                    // Highlight in grid
                    document.querySelectorAll('.episode-btn').forEach(btn => {
                        btn.classList.toggle('playing', btn.dataset.ep === String(autoEp));
                    });
                    // Auto-play if resuming from Continue tab
                    if (hasResume) {
                        toast(`Resuming EP ${autoEp} at ${formatTime(state.pendingResumeTime)}...`, 'info');
                        playEpisode();
                    } else {
                        toast(`Ready: EP ${autoEp}`, 'info');
                    }
                }
            }
        } catch (err) {
            grid.innerHTML = `<div class="no-results">Error: ${err.message}</div>`;
            toast(err.message, 'error');
        }
    }

    // === VIDEO PLAYER ENGINE ===
    function watchTimeHandler() {
        if (state.watchedMarked || !state.selectedAnime || !state.selectedEpisode) return;
        const video = document.getElementById('video-player');
        const currentTime = video.currentTime;
        const duration = video.duration || Infinity;
        state.currentPlaybackTime = currentTime;

        // Mark as watched after 80% of video OR 20 minutes, whichever comes first
        const threshold = Math.min(1200, duration * 0.8);
        if (currentTime >= threshold) {
            state.watchedMarked = true;
            // Update local history
            const localHist = state.history.find(h => h.anime_id === state.selectedAnime.id);
            if (localHist) {
                if (!Array.isArray(localHist.episodes_watched)) localHist.episodes_watched = [];
                if (!localHist.episodes_watched.includes(String(state.selectedEpisode))) {
                    localHist.episodes_watched.push(String(state.selectedEpisode));
                }
                localHist.episode = state.selectedEpisode;
                localHist.timestamp = new Date().toISOString();
            } else {
                state.history.unshift({
                    anime_id: state.selectedAnime.id,
                    title: state.selectedAnime.title,
                    episode: state.selectedEpisode,
                    episodes_watched: [String(state.selectedEpisode)],
                    mode: state.mode,
                    timestamp: new Date().toISOString()
                });
            }
            // Tell server to mark as watched
            fetch(`${API}/mark-watched`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    anime_id: state.selectedAnime.id,
                    episode: state.selectedEpisode
                })
            }).catch(() => {});
            renderEpisodeGrid();
            renderHistory();
        }
    }

    // Save playback progress to server (called every 30s during playback)
    function saveProgress() {
        if (!state.selectedAnime || !state.selectedEpisode) return;
        const video = document.getElementById('video-player');
        if (!video || !video.currentTime) return;
        fetch(`${API}/save-progress`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                anime_id: state.selectedAnime.id,
                episode: state.selectedEpisode,
                playback_time: Math.floor(video.currentTime)
            })
        }).catch(() => {}); // silent
    }

    function showPlayer(streamUrl) {
        const container = document.getElementById('video-player-container');
        const video = document.getElementById('video-player');
        const loading = document.getElementById('player-loading');

        container.style.display = 'block';
        loading.style.display = 'flex';
        state.isPlaying = true;

        // Watch time tracking  mark as watched after 80% or 20 min
        video.removeEventListener('timeupdate', watchTimeHandler);
        video.addEventListener('timeupdate', watchTimeHandler);

        // Save progress every 30 seconds
        if (state.progressSaveInterval) clearInterval(state.progressSaveInterval);
        state.progressSaveInterval = setInterval(saveProgress, 30000);

        // Destroy previous HLS instance
        if (state.hlsInstance) {
            state.hlsInstance.destroy();
            state.hlsInstance = null;
        }

        const isM3u8 = streamUrl.includes('.m3u8') || streamUrl.includes('master.txt');

        if (isM3u8 && Hls.isSupported()) {
            const hls = new Hls({
                xhrSetup: (xhr, url) => {
                    // If URL is already proxied, leave it
                    if (url.startsWith('/proxy-stream')) return;
                }
            });
            state.hlsInstance = hls;

            // Try direct first, fall back to proxy
            hls.loadSource(streamUrl);
            hls.attachMedia(video);

            hls.on(Hls.Events.MANIFEST_PARSED, () => {
                loading.style.display = 'none';
                if (state.pendingResumeTime > 0) {
                    video.currentTime = state.pendingResumeTime;
                    state.pendingResumeTime = 0;
                }
                video.play().catch(() => {});
            });

            hls.on(Hls.Events.ERROR, (event, data) => {
                if (data.fatal) {
                    if (data.type === Hls.ErrorTypes.NETWORK_ERROR && !streamUrl.startsWith('/proxy-stream')) {
                        // CORS failure  retry through proxy
                        console.log('[ANI-MATE] Direct stream failed, trying proxy...');
                        toast('Routing through proxy...', 'info');
                        hls.destroy();
                        const proxyUrl = `/proxy-stream?url=${encodeURIComponent(streamUrl)}`;
                        const hls2 = new Hls();
                        state.hlsInstance = hls2;
                        hls2.loadSource(proxyUrl);
                        hls2.attachMedia(video);
                        hls2.on(Hls.Events.MANIFEST_PARSED, () => {
                            loading.style.display = 'none';
                            if (state.pendingResumeTime > 0) {
                                video.currentTime = state.pendingResumeTime;
                                state.pendingResumeTime = 0;
                            }
                            video.play().catch(() => {});
                        });
                        hls2.on(Hls.Events.ERROR, (ev, d2) => {
                            if (d2.fatal) {
                                loading.style.display = 'none';
                                toast('Stream failed to load', 'error');
                            }
                        });
                    } else {
                        loading.style.display = 'none';
                        toast('Stream error  try another quality', 'error');
                    }
                }
            });
        } else if (video.canPlayType('application/vnd.apple.mpegurl') && isM3u8) {
            // Safari native HLS
            video.src = streamUrl;
            video.addEventListener('loadedmetadata', () => {
                loading.style.display = 'none';
                if (state.pendingResumeTime > 0) {
                    video.currentTime = state.pendingResumeTime;
                    state.pendingResumeTime = 0;
                }
                video.play().catch(() => {});
            }, { once: true });
        } else {
            // Direct MP4 or other format
            const tryUrl = async (url) => {
                video.src = url;
                video.addEventListener('loadeddata', () => {
                    loading.style.display = 'none';
                    if (state.pendingResumeTime > 0) {
                        video.currentTime = state.pendingResumeTime;
                        state.pendingResumeTime = 0;
                    }
                    video.play().catch(() => {});
                }, { once: true });
                video.addEventListener('error', () => {
                    if (!url.startsWith('/proxy-stream')) {
                        toast('Routing through proxy...', 'info');
                        tryUrl(`/proxy-stream?url=${encodeURIComponent(streamUrl)}`);
                    } else {
                        loading.style.display = 'none';
                        toast('Stream failed to load', 'error');
                    }
                }, { once: true });
            };
            tryUrl(streamUrl);
        }
    }

    function hidePlayer() {
        // Save final progress before closing
        saveProgress();
        if (state.progressSaveInterval) {
            clearInterval(state.progressSaveInterval);
            state.progressSaveInterval = null;
        }

        const container = document.getElementById('video-player-container');
        const video = document.getElementById('video-player');
        container.style.display = 'none';
        video.pause();
        video.removeAttribute('src');
        video.load();
        if (state.hlsInstance) {
            state.hlsInstance.destroy();
            state.hlsInstance = null;
        }
        state.isPlaying = false;
    }

    let playLock = false;
    async function playEpisode() {
        if (!state.selectedAnime || !state.selectedEpisode || playLock) return;
        playLock = true;

        const quality = document.getElementById('quality-select').value;
        const audio = document.getElementById('audio-select').value;

        toast(`Loading EP ${state.selectedEpisode}...`, 'info');

        try {
            const data = await apiCall('/play', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    anime_id: state.selectedAnime.id,
                    episode: state.selectedEpisode,
                    title: state.selectedAnime.title,
                    quality,
                    sub_or_dub: audio,
                    total_episodes: state.selectedAnime.epCount || null
                })
            });

            // Store available links for quality switching
            state.availableLinks = data.all_links || [];

            document.getElementById('np-detail').textContent =
                `EP ${state.selectedEpisode} // ${(data.resolution || quality).toUpperCase()} // ${audio.toUpperCase()} // ${data.provider || '?'}`;

            // Mark episode as playing in grid
            document.querySelectorAll('.episode-btn').forEach(btn => {
                btn.classList.remove('playing');
                if (btn.dataset.ep === String(state.selectedEpisode)) {
                    btn.classList.add('playing');
                }
            });

            // Reset watched tracking  episode marked as watched after 80% or 20min
            state.watchedMarked = false;
            state.currentPlaybackTime = 0;

            // Launch in-app player
            if (data.stream_url) {
                showPlayer(data.stream_url);
                toast(`Playing: ${state.selectedAnime.title} EP ${state.selectedEpisode}`, 'success');
            } else {
                toast('No stream URL available', 'error');
            }

            // Refresh history from server (background)
            loadHistory();
        } catch (err) {
            toast(`Playback error: ${err.message}`, 'error');
        } finally {
            playLock = false;
        }
    }

    // === DOWNLOAD ===
    async function startDownload() {
        if (!state.selectedAnime || !state.selectedEpisode) return;

        const quality = document.getElementById('quality-select').value;
        const audio = document.getElementById('audio-select').value;

        toast(`Starting download: EP ${state.selectedEpisode}...`, 'info');

        try {
            const data = await apiCall('/download', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    anime_id: state.selectedAnime.id,
                    episode: state.selectedEpisode,
                    title: state.selectedAnime.title,
                    quality,
                    sub_or_dub: audio
                })
            });

            if (data.download_id) {
                toast(`Downloading: ${data.filename}`, 'success');
                pollDownloadStatus(data.download_id, data.filename);
            }
        } catch (err) {
            toast(`Download error: ${err.message}`, 'error');
        }
    }

    function pollDownloadStatus(dlId, filename) {
        const poll = setInterval(async () => {
            try {
                const data = await apiCall(`/download-status?id=${encodeURIComponent(dlId)}`);
                if (data.status === 'complete') {
                    clearInterval(poll);
                    toast(`Download complete: ${filename}`, 'success');
                } else if (data.status === 'error') {
                    clearInterval(poll);
                    toast(`Download failed: ${data.error}`, 'error');
                }
                // Still downloading  silent polling
            } catch {
                clearInterval(poll);
            }
        }, 2000);
    }

    async function loadHistory() {
        try {
            const data = await apiCall('/history');
            state.history = data.forge || [];
            renderHistory();
        } catch { /* silent */ }
    }

    // === RENDER FUNCTIONS ===
    function renderResults() {
        const container = document.getElementById('results-container');
        if (state.results.length === 0) {
            container.innerHTML = '<div class="no-results">No results found</div>';
            return;
        }

        const series = state.results.filter(r => r.type === 'series');
        const shorts = state.results.filter(r => r.type === 'short');
        const movies = state.results.filter(r => r.type === 'movie');

        let html = '';
        if (series.length > 0) {
            html += '<div class="section-label">SERIES</div>';
            html += renderResultGroup(series);
        }
        if (shorts.length > 0) {
            html += '<div class="section-label">SHORT SERIES</div>';
            html += renderResultGroup(shorts);
        }
        if (movies.length > 0) {
            html += '<div class="section-label">MOVIES & SPECIALS</div>';
            html += renderResultGroup(movies);
        }

        container.innerHTML = html;
        bindResultCards(container);
        bindStarButtons(container);
    }

    function renderResultGroup(items) {
        return items.map(r => {
            const typeLabel = r.type === 'series' ? 'SERIES' : r.type === 'short' ? 'SHORT' : 'MOVIE';
            const isFav = state.favorites.some(f => f.id === r.id);
            const coverHtml = r.cover ? `<div class="release-cover-wrap"><img class="release-cover" src="${r.cover}" loading="lazy" alt=""></div>` : '';
            const hoverText = r.description ? r.description.replace(/<[^>]*>/g, '').replace(/&/g, '&amp;').replace(/"/g, '&quot;') : r.name.replace(/"/g, '&quot;');
            return `<div class="result-card glass ${state.selectedAnime?.id === r.id ? 'selected' : ''}"
                 data-id="${r.id}" data-title="${r.name.replace(/"/g, '&quot;')}" data-eps="${r.episodes}" title="${hoverText}">
                <div class="result-card-row">
                    <button class="fav-star ${isFav ? 'active' : ''}" data-fav-id="${r.id}" data-fav-name="${r.name.replace(/"/g, '&quot;')}" data-fav-eps="${r.episodes}" title="${isFav ? 'Remove from favorites' : 'Add to favorites'}">${isFav ? '&#9733;' : '&#9734;'}</button>
                    ${coverHtml}
                    <div class="result-info">
                        <div class="result-title">${r.name}</div>
                        <div class="result-meta"><span class="result-type ${r.type}">${typeLabel}</span>${r.episodes} EP</div>
                    </div>
                </div>
            </div>`;
        }).join('');
    }

    const RANGE_SIZE = 50;

    function renderEpisodeGrid() {
        const grid = document.getElementById('episode-grid');
        const rangeSelector = document.getElementById('range-selector');

        if (state.episodes.length === 0) {
            grid.innerHTML = '<div class="no-results">No episodes available</div>';
            rangeSelector.style.display = 'none';
            return;
        }

        // Show range selector for long series
        if (state.episodes.length > RANGE_SIZE) {
            rangeSelector.style.display = 'flex';
            const totalRanges = Math.ceil(state.episodes.length / RANGE_SIZE);
            if (!state.currentRange) state.currentRange = 0;
            rangeSelector.innerHTML = '';
            for (let i = 0; i < totalRanges; i++) {
                const start = i * RANGE_SIZE + 1;
                const end = Math.min((i + 1) * RANGE_SIZE, state.episodes.length);
                const btn = document.createElement('button');
                btn.className = `range-btn ${i === state.currentRange ? 'active' : ''}`;
                btn.textContent = `${start}-${end}`;
                btn.title = `Show episodes ${start} to ${end}`;
                btn.addEventListener('click', () => {
                    state.currentRange = i;
                    renderEpisodeGrid();
                });
                rangeSelector.appendChild(btn);
            }
        } else {
            rangeSelector.style.display = 'none';
            state.currentRange = 0;
        }

        // Slice episodes by current range
        const start = (state.currentRange || 0) * RANGE_SIZE;
        const visibleEps = state.episodes.slice(start, start + RANGE_SIZE);

        grid.innerHTML = visibleEps.map(ep => {
            const histEntry = state.history.find(h => h.anime_id === state.selectedAnime?.id);
            const watchedEps = histEntry?.episodes_watched || [];
            const isWatched = watchedEps.includes(String(ep)) ||
                (histEntry && String(histEntry.episode) === String(ep));
            return `<button class="episode-btn ${isWatched ? 'watched' : ''} ${state.selectedEpisode === ep ? 'playing' : ''}"
                           data-ep="${ep}" title="Episode ${ep}${isWatched ? ' (watched)' : ''} - Click to select, Enter to play">${isWatched ? '&#10003; ' : ''}${ep}</button>`;
        }).join('');

        grid.querySelectorAll('.episode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                state.selectedEpisode = btn.dataset.ep;
                document.querySelectorAll('.episode-btn').forEach(b => b.classList.remove('playing'));
                btn.classList.add('playing');
                updatePlayButton();

                document.getElementById('np-detail').textContent =
                    `EP ${btn.dataset.ep} selected // ${state.mode.toUpperCase()}`;
            });
        });
    }

    function renderHistory() {
        const list = document.getElementById('history-list');
        if (state.history.length === 0) {
            list.innerHTML = '<div class="no-results">No watch history yet</div>';
            return;
        }

        list.innerHTML = state.history.map(h => {
            const time = h.timestamp ? new Date(h.timestamp).toLocaleDateString() : '--';
            return `<div class="history-item glass" data-id="${h.anime_id}" data-title="${(h.title || '').replace(/"/g, '&quot;')}" title="Click to load ${(h.title || h.anime_id).replace(/"/g, '&quot;')} episodes">
                <div class="history-title">${h.title || h.anime_id}</div>
                <div class="history-meta">EP <span>${h.episode}</span> // ${(h.mode || 'sub').toUpperCase()} // ${time}</div>
            </div>`;
        }).join('');

        list.querySelectorAll('.history-item').forEach(item => {
            item.addEventListener('click', () => {
                const id = item.dataset.id;
                const title = item.dataset.title;
                // Reload this anime
                loadEpisodes(id, title, '?');
            });
            item.addEventListener('contextmenu', (e) => {
                showCtxMenu(e, item.dataset.id, item.dataset.title, 'history');
            });
        });
    }

    function updatePlayButton() {
        const ready = state.selectedAnime && state.selectedEpisode;
        document.getElementById('play-btn').disabled = !ready;
        document.getElementById('dl-btn').disabled = !ready;
    }

    // === EVENT LISTENERS ===
    document.getElementById('search-input').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const q = e.target.value.trim();
            if (q) searchAnime(q);
        }
    });

    document.getElementById('search-btn').addEventListener('click', () => {
        const q = document.getElementById('search-input').value.trim();
        if (q) searchAnime(q);
    });

    document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            state.mode = btn.dataset.mode;
            document.getElementById('audio-select').value = state.mode;
        });
    });

    document.getElementById('audio-select').addEventListener('change', (e) => {
        state.mode = e.target.value;
        document.querySelectorAll('.mode-btn').forEach(b => {
            b.classList.toggle('active', b.dataset.mode === state.mode);
        });
    });

    // Quality switching during playback (uses cached links, no server re-fetch)
    document.getElementById('quality-select').addEventListener('change', (e) => {
        if (!state.isPlaying || state.availableLinks.length === 0) return;
        const wanted = e.target.value;
        let match;
        if (wanted === 'best') {
            match = state.availableLinks[0];
        } else if (wanted === 'worst') {
            match = state.availableLinks[state.availableLinks.length - 1];
        } else {
            match = state.availableLinks.find(l => l.resolution.includes(wanted));
        }
        if (match) {
            toast(`Switching to ${match.resolution}...`, 'info');
            state.pendingResumeTime = video.currentTime;
            showPlayer(match.url);
            document.getElementById('np-detail').textContent =
                document.getElementById('np-detail').textContent.replace(/\/\/\s*\S+\s*\/\//, `// ${match.resolution.toUpperCase()} //`);
        } else {
            toast(`${wanted} not available for this episode`, 'error');
        }
    });

    document.getElementById('play-btn').addEventListener('click', playEpisode);

    document.getElementById('player-back-btn').addEventListener('click', hidePlayer);

    document.getElementById('dl-btn').addEventListener('click', startDownload);

    // Auto-play toggle (persisted to localStorage)
    const savedAutoPlay = localStorage.getItem('ani-mate-autoplay') === 'true';
    state.autoPlay = savedAutoPlay;
    document.getElementById('autoplay-toggle').checked = savedAutoPlay;

    document.getElementById('autoplay-toggle').addEventListener('change', (e) => {
        state.autoPlay = e.target.checked;
        localStorage.setItem('ani-mate-autoplay', e.target.checked);
        toast(state.autoPlay ? 'Auto-play ON' : 'Auto-play OFF', 'info');
    });

    // Auto-play: when video ends, play next episode
    document.getElementById('video-player').addEventListener('ended', () => {
        if (!state.autoPlay || !state.selectedAnime || !state.episodes.length) return;
        const currentIdx = state.episodes.indexOf(state.selectedEpisode);
        if (currentIdx === -1 || currentIdx >= state.episodes.length - 1) {
            toast('No more episodes  series complete!', 'info');
            return;
        }
        const nextEp = state.episodes[currentIdx + 1];
        state.selectedEpisode = nextEp;
        state.pendingResumeTime = 0;
        updatePlayButton();
        document.getElementById('np-detail').textContent =
            `EP ${nextEp} selected // ${state.mode.toUpperCase()}`;
        document.querySelectorAll('.episode-btn').forEach(btn => {
            btn.classList.toggle('playing', btn.dataset.ep === String(nextEp));
        });
        toast(`Auto-playing EP ${nextEp}...`, 'info');
        playEpisode();
    });

    document.getElementById('clear-history-btn').addEventListener('click', () => {
        if (confirm('Clear all watch history?')) {
            state.history = [];
            renderHistory();
            toast('History cleared', 'info');
        }
    });

    // === CONTEXT MENU (right-click to remove) ===
    const ctxMenu = document.getElementById('ctx-menu');
    let ctxTarget = null;

    function showCtxMenu(e, animeId, title, source) {
        e.preventDefault();
        ctxTarget = { animeId, title, source };
        ctxMenu.style.left = e.clientX + 'px';
        ctxMenu.style.top = e.clientY + 'px';
        ctxMenu.style.display = 'block';
    }

    document.addEventListener('click', () => { ctxMenu.style.display = 'none'; });
    document.addEventListener('contextmenu', (e) => {
        if (!e.target.closest('.ctx-menu')) ctxMenu.style.display = 'none';
    });

    document.getElementById('ctx-remove').addEventListener('click', async () => {
        if (!ctxTarget) return;
        ctxMenu.style.display = 'none';
        try {
            await apiCall(`/history/remove?id=${encodeURIComponent(ctxTarget.animeId)}`);
            state.history = state.history.filter(h => h.anime_id !== ctxTarget.animeId);
            renderHistory();
            if (ctxTarget.source === 'continue') {
                state.continueResults = state.continueResults.filter(r => r.anime_id !== ctxTarget.animeId);
                renderContinue();
            }
            toast(`Removed "${ctxTarget.title}"`, 'info');
        } catch (err) {
            toast('Failed to remove: ' + err.message, 'error');
        }
        ctxTarget = null;
    });

    // Keyboard shortcuts
    function navigateEpisode(direction) {
        if (!state.episodes.length || !state.selectedAnime) return;
        const currentIdx = state.episodes.indexOf(state.selectedEpisode);
        let newIdx;
        if (currentIdx === -1) {
            newIdx = direction > 0 ? 0 : state.episodes.length - 1;
        } else {
            newIdx = currentIdx + direction;
        }
        if (newIdx < 0 || newIdx >= state.episodes.length) return;

        state.selectedEpisode = state.episodes[newIdx];
        updatePlayButton();
        document.getElementById('np-detail').textContent =
            `EP ${state.selectedEpisode} selected // ${state.mode.toUpperCase()}`;

        // Update grid highlight
        document.querySelectorAll('.episode-btn').forEach(btn => {
            btn.classList.toggle('playing', btn.dataset.ep === String(state.selectedEpisode));
            if (btn.dataset.ep === String(state.selectedEpisode)) {
                btn.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
        });
    }

    document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

        switch (e.key) {
            case '/':
                e.preventDefault();
                document.getElementById('search-input').focus();
                break;
            case 'Enter':
                if (state.selectedEpisode) playEpisode();
                break;
            case 'Escape':
                if (state.isPlaying) {
                    hidePlayer();
                } else {
                    document.getElementById('search-input').blur();
                }
                break;
            case 'ArrowRight':
                e.preventDefault();
                if (state.isPlaying) {
                    document.getElementById('video-player').currentTime += 5;
                } else {
                    navigateEpisode(1);
                }
                break;
            case 'ArrowLeft':
                e.preventDefault();
                if (state.isPlaying) {
                    document.getElementById('video-player').currentTime -= 5;
                } else {
                    navigateEpisode(-1);
                }
                break;
            case ' ':
                if (state.isPlaying) {
                    e.preventDefault();
                    const video = document.getElementById('video-player');
                    video.paused ? video.play() : video.pause();
                }
                break;
            case 'f':
                if (state.isPlaying) {
                    const video = document.getElementById('video-player');
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        video.requestFullscreen().catch(() => {});
                    }
                }
                break;
        }
    });

    // === TABS ===
    state.activeTab = 'search';
    state.favorites = [];
    state.dailyResults = [];
    state.releasesDate = null;
    state.releasesResults = [];
    state.continueResults = [];
    state.pendingAutoEpisode = null;

    function switchTab(tab) {
        state.activeTab = tab;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
        const searchBox = document.querySelector('.search-box');
        const container = document.getElementById('results-container');

        if (tab === 'search') {
            searchBox.style.display = 'block';
            if (state.results.length > 0) renderResults();
            else container.innerHTML = '<div class="no-results">Enter a search query to find anime</div>';
        } else if (tab === 'continue') {
            searchBox.style.display = 'none';
            loadContinue();
        } else if (tab === 'daily') {
            searchBox.style.display = 'none';
            loadDaily();
        } else if (tab === 'releases') {
            searchBox.style.display = 'none';
            state.releasesDate = new Date();
            loadReleases();
        } else if (tab === 'favs') {
            searchBox.style.display = 'none';
            loadFavorites();
        }
    }

    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => switchTab(btn.dataset.tab));
    });

    // === DAILY ===
    async function loadDaily() {
        const container = document.getElementById('results-container');
        container.innerHTML = '<div class="loading-indicator">LOADING TRENDING...</div>';
        try {
            const data = await apiCall(`/daily?mode=${state.mode}`);
            state.dailyResults = data.results || [];
            renderDaily();
        } catch (err) {
            container.innerHTML = `<div class="no-results">Error: ${err.message}</div>`;
        }
    }

    function renderDaily() {
        const container = document.getElementById('results-container');
        if (state.dailyResults.length === 0) {
            container.innerHTML = '<div class="no-results">No trending anime today</div>';
            return;
        }
        container.innerHTML = '<div class="section-label">TRENDING TODAY</div>' +
            state.dailyResults.map((r, i) => {
                const isFav = state.favorites.some(f => f.id === r.id);
                const coverHtml = r.cover ? `<div class="release-cover-wrap"><img class="release-cover" src="${r.cover}" loading="lazy" alt=""></div>` : '';
                const dailyHover = r.description ? r.description.replace(/<[^>]*>/g, '').replace(/&/g, '&amp;').replace(/"/g, '&quot;') : r.name.replace(/"/g, '&quot;');
                return `<div class="result-card glass" data-id="${r.id}" data-title="${r.name.replace(/"/g, '&quot;')}" data-eps="${r.episodes}" title="${dailyHover}">
                    <div class="result-card-row">
                        <button class="fav-star ${isFav ? 'active' : ''}" data-fav-id="${r.id}" data-fav-name="${r.name.replace(/"/g, '&quot;')}" data-fav-eps="${r.episodes}" title="${isFav ? 'Remove from favorites' : 'Add to favorites'}">${isFav ? '&#9733;' : '&#9734;'}</button>
                        ${coverHtml}
                        <div class="result-info">
                            <div class="result-title">${r.name}</div>
                            <div class="result-meta"><span class="result-type ${r.type}">#${i + 1}</span>${r.episodes} EP</div>
                        </div>
                    </div>
                </div>`;
            }).join('');
        bindResultCards(container);
        bindStarButtons(container);
    }

    // === CONTINUE WATCHING ===
    async function loadContinue() {
        const container = document.getElementById('results-container');
        container.innerHTML = '<div class="loading-indicator">LOADING CONTINUE LIST...</div>';
        try {
            const data = await apiCall('/continue');
            state.continueResults = data.continue_list || [];
            renderContinue();
        } catch (err) {
            container.innerHTML = `<div class="no-results">Error: ${err.message}</div>`;
        }
    }

    function formatTime(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${String(s).padStart(2, '0')}`;
    }

    function renderContinue() {
        const container = document.getElementById('results-container');
        if (state.continueResults.length === 0) {
            container.innerHTML = '<div class="no-results">No anime to continue. Start watching something!</div>';
            return;
        }
        container.innerHTML = '<div class="section-label">CONTINUE WATCHING</div>' +
            state.continueResults.map(r => {
                const watchedCount = Array.isArray(r.episodes_watched) ? r.episodes_watched.length : 1;
                const totalLabel = r.total_episodes ? `${watchedCount}/${r.total_episodes}` : `${watchedCount} watched`;
                const hasResume = r.resume_time && r.resume_time > 10;
                const resumeLabel = hasResume
                    ? `RESUME EP ${r.resume_episode} at ${formatTime(r.resume_time)}`
                    : `NEXT: EP ${r.next_episode}`;
                const resumeEp = hasResume ? r.resume_episode : r.next_episode;
                const resumeTime = hasResume ? r.resume_time : 0;
                return `<div class="result-card glass" data-id="${r.anime_id}" data-title="${(r.title || '').replace(/"/g, '&quot;')}" data-eps="${r.total_episodes || '?'}" data-resume-ep="${resumeEp}" data-resume-time="${resumeTime}" title="Click to resume watching">
                    <div class="result-card-row">
                        <div class="result-info">
                            <div class="result-title">${r.title || r.anime_id}</div>
                            <div class="result-meta">
                                <span class="result-type series">${resumeLabel}</span>
                                ${totalLabel} // ${(r.mode || 'sub').toUpperCase()}
                            </div>
                        </div>
                    </div>
                </div>`;
            }).join('');

        // Click to load episodes and auto-select resume episode
        container.querySelectorAll('.result-card').forEach(card => {
            card.addEventListener('click', () => {
                const resumeEp = card.dataset.resumeEp;
                const resumeTime = parseFloat(card.dataset.resumeTime) || 0;
                state.pendingAutoEpisode = resumeEp;
                state.pendingResumeTime = resumeTime;
                loadEpisodes(card.dataset.id, card.dataset.title, parseInt(card.dataset.eps) || '?');
            });
            card.addEventListener('contextmenu', (e) => {
                showCtxMenu(e, card.dataset.id, card.dataset.title, 'continue');
            });
        });
    }

    // === RELEASES (AIRING SCHEDULE) ===
    async function loadReleases() {
        const container = document.getElementById('results-container');
        if (!state.releasesDate) state.releasesDate = new Date();
        const dateStr = state.releasesDate.toISOString().slice(0, 10);
        container.innerHTML = '<div class="loading-indicator">SCANNING AIRING SCHEDULE...</div>';
        try {
            const data = await apiCall(`/releases?date=${dateStr}`);
            state.releasesResults = data.results || [];
            renderReleases();
        } catch (err) {
            container.innerHTML = `<div class="no-results">Error: ${err.message}</div>`;
        }
    }

    function renderReleases() {
        const container = document.getElementById('results-container');
        const results = state.releasesResults;
        const d = state.releasesDate;
        const dateLabel = d.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
        const isToday = d.toDateString() === new Date().toDateString();

        let html = `<div class="date-nav">
            <button class="date-nav-btn" id="date-prev" title="Previous day">&laquo; PREV</button>
            <span class="date-nav-label" title="Airing schedule date">${isToday ? 'TODAY &mdash; ' : ''}${dateLabel.toUpperCase()}</span>
            <button class="date-nav-btn" id="date-next" title="Next day">NEXT &raquo;</button>
        </div>`;

        if (results.length === 0) {
            html += '<div class="no-results">No releases scheduled for this day</div>';
            container.innerHTML = html;
            bindDateNav();
            return;
        }

        const slots = { night: [], morning: [], afternoon: [], evening: [] };
        for (const r of results) {
            const h = new Date(r.airingAt * 1000).getHours();
            if (h >= 6 && h < 12) slots.morning.push(r);
            else if (h >= 12 && h < 18) slots.afternoon.push(r);
            else if (h >= 18) slots.evening.push(r);
            else slots.night.push(r);
        }

        const labels = {
            morning: 'MORNING (06:00-12:00)',
            afternoon: 'AFTERNOON (12:00-18:00)',
            evening: 'EVENING (18:00-00:00)',
            night: 'NIGHT (00:00-06:00)'
        };

        for (const [slot, items] of Object.entries(slots)) {
            if (items.length === 0) continue;
            html += `<div class="section-label">${labels[slot]}</div>`;
            html += items.map(r => {
                const airTime = new Date(r.airingAt * 1000).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                const fmt = r.format || 'TV';
                return `<div class="result-card glass release-card"
                     data-release-title="${(r.title || '').replace(/"/g, '&quot;')}"
                     data-release-romaji="${(r.title_romaji || '').replace(/"/g, '&quot;')}"
                     title="Click to search and watch ${(r.title || '').replace(/"/g, '&quot;')}">
                    <div class="result-card-row">
                        <div class="release-cover-wrap">
                            ${r.cover ? `<img class="release-cover" src="${r.cover}" loading="lazy" alt="">` : ''}
                        </div>
                        <div class="result-info">
                            <div class="result-title">${r.title}</div>
                            <div class="result-meta">
                                <span class="result-type series">${fmt}</span>
                                EP ${r.episode}${r.totalEpisodes ? '/' + r.totalEpisodes : ''}
                                &mdash; <span class="release-time">${airTime}</span>
                            </div>
                        </div>
                    </div>
                </div>`;
            }).join('');
        }

        container.innerHTML = html;
        bindDateNav();
        bindReleaseCards();
    }

    function bindDateNav() {
        document.getElementById('date-prev')?.addEventListener('click', () => {
            state.releasesDate = new Date(state.releasesDate.getTime() - 86400000);
            loadReleases();
        });
        document.getElementById('date-next')?.addEventListener('click', () => {
            state.releasesDate = new Date(state.releasesDate.getTime() + 86400000);
            loadReleases();
        });
    }

    function bindReleaseCards() {
        document.querySelectorAll('.release-card').forEach(card => {
            card.addEventListener('click', async () => {
                const title = card.dataset.releaseTitle;
                const romaji = card.dataset.releaseRomaji;
                toast(`Searching for ${title}...`, 'info');
                try {
                    let data = await apiCall(`/search?q=${encodeURIComponent(title)}&mode=${state.mode}`);
                    if ((!data.results || data.results.length === 0) && romaji && romaji !== title) {
                        data = await apiCall(`/search?q=${encodeURIComponent(romaji)}&mode=${state.mode}`);
                    }
                    if (data.results && data.results.length > 0) {
                        const match = data.results[0];
                        loadEpisodes(match.id, match.name, match.episodes);
                    } else {
                        toast('Not found on streaming source', 'error');
                    }
                } catch (err) {
                    toast(`Search error: ${err.message}`, 'error');
                }
            });
        });
    }

    // === FAVORITES ===
    async function loadFavorites() {
        const container = document.getElementById('results-container');
        try {
            const data = await apiCall('/favorites');
            state.favorites = data.favorites || [];
            renderFavorites();
        } catch (err) {
            container.innerHTML = `<div class="no-results">Error: ${err.message}</div>`;
        }
    }

    function renderFavorites() {
        const container = document.getElementById('results-container');
        if (state.favorites.length === 0) {
            container.innerHTML = '<div class="no-results">No favorites yet. Star an anime to save it.</div>';
            return;
        }
        container.innerHTML = '<div class="section-label">FAVORITES</div>' +
            state.favorites.map(r => `<div class="result-card glass" data-id="${r.id}" data-title="${r.name.replace(/"/g, '&quot;')}" data-eps="${r.episodes}" title="${r.name.replace(/"/g, '&quot;')}">
                <div class="result-card-row">
                    <button class="fav-star active" data-fav-id="${r.id}" data-fav-name="${r.name.replace(/"/g, '&quot;')}" data-fav-eps="${r.episodes}" title="Remove from favorites">&#9733;</button>
                    <div class="result-info">
                        <div class="result-title">${r.name}</div>
                        <div class="result-meta">${r.episodes} EP</div>
                    </div>
                </div>
            </div>`).join('');
        bindResultCards(container);
        bindStarButtons(container);
    }

    async function toggleFavorite(id, name, episodes) {
        const isFav = state.favorites.some(f => f.id === id);
        try {
            if (isFav) {
                await apiCall(`/favorites/${encodeURIComponent(id)}`, { method: 'DELETE' });
                state.favorites = state.favorites.filter(f => f.id !== id);
                toast(`Removed from favorites`, 'info');
            } else {
                const data = await apiCall('/favorites', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id, name, episodes: parseInt(episodes) || 0 })
                });
                state.favorites = data.favorites || [];
                toast(`Added to favorites`, 'success');
            }
        } catch (err) {
            toast(`Favorites error: ${err.message}`, 'error');
        }
        updateHeaderStar();
        // Re-render current tab if needed
        if (state.activeTab === 'favs') renderFavorites();
        else if (state.activeTab === 'daily') renderDaily();
        else if (state.activeTab === 'releases') renderReleases();
        else if (state.activeTab === 'continue') renderContinue();
    }

    function updateHeaderStar() {
        const star = document.getElementById('header-fav-star');
        if (state.selectedAnime) {
            const isFav = state.favorites.some(f => f.id === state.selectedAnime.id);
            star.innerHTML = isFav ? '&#9733;' : '&#9734;';
            star.classList.toggle('active', isFav);
        }
    }

    document.getElementById('header-fav-star').addEventListener('click', () => {
        if (state.selectedAnime) {
            toggleFavorite(state.selectedAnime.id, state.selectedAnime.title, state.selectedAnime.epCount);
        }
    });

    // Shared helpers for binding cards and stars
    function bindResultCards(container) {
        container.querySelectorAll('.result-card').forEach(card => {
            card.addEventListener('click', (e) => {
                if (e.target.closest('.fav-star')) return;
                document.querySelectorAll('.result-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                loadEpisodes(card.dataset.id, card.dataset.title, parseInt(card.dataset.eps));
            });
        });
    }

    function bindStarButtons(container) {
        container.querySelectorAll('.fav-star').forEach(star => {
            star.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleFavorite(star.dataset.favId, star.dataset.favName, star.dataset.favEps);
            });
        });
    }

    // === INIT ===
    async function init() {
        await checkStatus();
        await loadHistory();
        // Pre-load favorites for star state
        try {
            const data = await apiCall('/favorites');
            state.favorites = data.favorites || [];
        } catch { /* silent */ }
        setInterval(checkStatus, 30000);
    }

    init();
    </script>
</body>
</html>
